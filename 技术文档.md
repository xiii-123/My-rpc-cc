# yu-rpc 技术文档

## 项目概述

yu-rpc是一个基于Java开发的轻量级RPC框架，采用现代化的技术栈，展示了从基础到高级的分布式系统设计理念。项目采用模块化设计，包含核心实现、简化版本和Spring Boot集成等多个模块。

## 技术栈

### 核心技术
- **Java 8** - 基础开发语言
- **Vert.x 4.5.1** - 高性能异步网络框架
- **Etcd** - 云原生存储中间件（服务注册中心）
- **ZooKeeper** - 分布式协调工具（备选注册中心）

### 工具库
- **Hutool 5.8.16** - Java工具库
- **Logback 1.3.12** - 日志框架
- **Lombok 1.18.30** - 代码简化工具
- **JUnit** - 单元测试框架

### 序列化方案
- **JDK序列化** - 默认实现
- **JSON** - 轻量级文本格式
- **Hessian** - 高性能二进制格式
- **Kryo** - 快速高效的序列化框架

## 模块结构

```
yu-rpc/
├── yu-rpc-core/              # 核心框架实现
├── yu-rpc-easy/              # 简化版本（适合初学者）
├── yu-rpc-spring-boot-starter/  # Spring Boot集成
├── example-common/           # 示例公共模块
├── example-consumer/         # 消费者示例
├── example-provider/         # 提供者示例
├── example-springboot-*      # Spring Boot集成示例
└── docs/                     # 项目文档
```

## 核心架构

### 1. 整体架构设计

yu-rpc采用分层架构设计，从上到下分为：

```
┌─────────────────────────────────────────┐
│              API层                       │
│    ServiceProxyFactory.getProxy()       │
└─────────────────────────────────────────┘
                    │
┌─────────────────────────────────────────┐
│             代理层                        │
│       ServiceProxy.invoke()             │
└─────────────────────────────────────────┘
                    │
┌─────────────────────────────────────────┐
│            调用处理层                     │
│  负载均衡 → 重试 → 容错 → 网络调用        │
└─────────────────────────────────────────┘
                    │
┌─────────────────────────────────────────┐
│            通信层                        │
│      自定义TCP协议 + Vert.x              │
└─────────────────────────────────────────┘
                    │
┌─────────────────────────────────────────┐
│           注册中心层                      │
│    Etcd/ZooKeeper 服务发现              │
└─────────────────────────────────────────┘
```

### 2. 核心组件详解

#### 2.1 服务代理 (ServiceProxy)

位置：`yu-rpc-core/src/main/java/com/yupi/yurpc/proxy/ServiceProxy.java`

**职责**：
- 创建服务接口的代理对象
- 拦截方法调用，转换为RPC请求
- 整合服务发现、负载均衡、重试、容错等功能

**核心流程**：
```java
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    // 1. 构造RPC请求
    RpcRequest rpcRequest = RpcRequest.builder()
        .serviceName(serviceName)
        .methodName(method.getName())
        .parameterTypes(method.getParameterTypes())
        .args(args)
        .build();

    // 2. 服务发现
    List<ServiceMetaInfo> services = registry.serviceDiscovery(serviceKey);

    // 3. 负载均衡
    ServiceMetaInfo selectedService = loadBalancer.select(requestParams, services);

    // 4. 发起调用（带重试）
    RpcResponse response = retryStrategy.doRetry(() ->
        VertxTcpClient.doRequest(rpcRequest, selectedService)
    );

    return response.getData();
}
```

#### 2.2 自定义协议设计

**协议消息结构**：
```
+--------+--------+--------+--------+--------+--------+--------+--------+
|  Magic | Version|  Type  |  Status|Request | Body   | Header |  Body  |
| Number | Number | Number | Number |   ID   | Length | Length |  Data  |
| (4B)   | (1B)   | (1B)   | (1B)   | (8B)   | (4B)   | (17B)  | (N B)  |
+--------+--------+--------+--------+--------+--------+--------+--------+
```

**关键常量**（ProtocolConstant.java）：
```java
// 魔数：用于协议识别
public static final int PROTOCOL_MAGIC = 0xCAFEBABE;

// 协议版本
public static final byte PROTOCOL_VERSION = 1;

// 消息类型
REQUEST(0),      // 请求
RESPONSE(1),     // 响应
HEART_BEAT(2),   // 心跳
OTHERS(3);       // 其他
```

**协议编解码**：
- `ProtocolMessageEncoder` - 将Java对象编码为字节流
- `ProtocolMessageDecoder` - 从字节流解码为Java对象
- 处理TCP粘包问题

#### 2.3 网络通信层

**VertxTcpClient** - TCP客户端实现
- 使用Vert.x的NetClient进行网络通信
- 支持自定义协议编解码
- 每次请求创建新连接（可优化点）

**VertxTcpServer** - TCP服务器实现
- 基于Vert.x的NetServer
- 处理客户端连接和请求
- 通过反射调用本地服务实现

#### 2.4 服务注册与发现

**注册中心接口**（Registry.java）：
```java
public interface Registry {
    void init(RegistryConfig registryConfig);           // 初始化
    void register(ServiceMetaInfo serviceMetaInfo);     // 注册服务
    void unRegister(ServiceMetaInfo serviceMetaInfo);   // 注销服务
    List<ServiceMetaInfo> serviceDiscovery(String serviceKey);  // 服务发现
    void heartBeat();                                  // 心跳检测
    void destroy();                                     // 销毁资源
}
```

**实现类**：
- `EtcdRegistry` - 基于Etcd的实现
- `ZooKeeperRegistry` - 基于ZooKeeper的实现
- `LocalRegistry` - 本地注册中心（测试用）

**服务元信息**：
```java
public class ServiceMetaInfo {
    private String serviceName;      // 服务名
    private String serviceVersion;   // 版本号
    private String serviceHost;      // 主机地址
    private Integer servicePort;     // 端口号
    private String serviceGroup = "default";  // 服务分组
}
```

#### 2.5 负载均衡

**负载均衡接口**：
```java
public interface LoadBalancer {
    ServiceMetaInfo select(Map<String, Object> requestParams,
                          List<ServiceMetaInfo> serviceMetaInfoList);
}
```

**实现策略**：
1. **RandomLoadBalancer** - 随机选择
2. **RoundRobinLoadBalancer** - 轮询选择
3. **ConsistentHashLoadBalancer** - 一致性哈希

**一致性哈希实现要点**：
- 使用TreeMap维护虚拟节点环
- 支持权重配置
- 解决数据倾斜问题

#### 2.6 容错与重试

**重试策略接口**：
```java
public interface RetryStrategy {
    RpcResponse doRetry(Callable<RpcResponse> callable) throws Exception;
}
```

**重试实现**：
- `NoRetryStrategy` - 不重试
- `FixedIntervalRetryStrategy` - 固定间隔重试
- 使用Guava Retrying库实现

**容错策略接口**：
```java
public interface TolerantStrategy {
    RpcResponse doTolerant(RpcResponse rpcResponse, Exception e);
}
```

**容错实现**：
- `FailFastTolerantStrategy` - 快速失败
- `FailOverTolerantStrategy` - 失败转移
- `FailSafeTolerantStrategy` - 失败安全
- `FailBackTolerantStrategy` - 失败重试

#### 2.7 序列化机制

**序列化器接口**：
```java
public interface Serializer {
    byte[] serialize(Object object);
    Object deserialize(byte[] bytes, Class<?> clazz);
}
```

**SPI扩展机制**：
- 通过`META-INF/rpc/system/`配置文件加载实现
- 支持运行时动态切换序列化方式
- 工厂模式创建实例

#### 2.8 配置管理

**全局配置**（RpcConfig.java）：
```java
@Data
public class RpcConfig {
    private String name = "yu-rpc";                    // 框架名称
    private String version = "1.0";                    // 框架版本
    private String serverHost = "localhost";           // 服务器主机
    private Integer serverPort = 8080;                 // 服务器端口
    private String serializer = SerializerKeys.JDK;    // 序列化器
    private String loadBalancer = LoadBalancerKeys.ROUND_ROBIN;  // 负载均衡
    private String retryStrategy = RetryStrategyKeys.NO;         // 重试策略
    private String tolerantStrategy = TolerantStrategyKeys.FAIL_FAST;  // 容错策略
    private boolean mock = false;                      // 模拟调用
    private RegistryConfig registryConfig = new RegistryConfig();  // 注册中心配置
}
```

**配置加载**：
- 使用`ConfigUtils`从配置文件加载
- 支持默认配置
- 双检锁单例模式管理

### 3. Spring Boot集成

#### 3.1 自动配置

**启动引导**：
- `ProviderBootstrap` - 服务提供者启动
- `ConsumerBootstrap` - 服务消费者启动
- `RpcInitBootstrap` - RPC框架初始化

#### 3.2 注解支持

**@EnableRpc** - 启用RPC框架
```java
@EnableRpc(needServer = true)
@SpringBootApplication
public class ProviderApplication {
    public static void main(String[] args) {
        SpringApplication.run(ProviderApplication.class, args);
    }
}
```

**@RpcReference** - 引用远程服务
```java
@Service
public class ExampleServiceImpl implements ExampleService {
    @RpcReference
    private UserService userService;
}
```

## 项目亮点

### 1. 设计模式应用

- **工厂模式**：各种组件的工厂类（SerializerFactory, LoadBalancerFactory等）
- **策略模式**：负载均衡、重试、容错等可插拔策略
- **代理模式**：JDK动态代理实现远程调用
- **装饰者模式**：TCP处理器解决粘包问题
- **单例模式**：RpcApplication全局配置管理

### 2. 技术特色

1. **高性能网络通信**
   - 基于Vert.x的异步非阻塞IO
   - 自定义二进制协议
   - 优化的序列化方案

2. **完善的扩展机制**
   - SPI机制支持组件扩展
   - 策略模式支持算法扩展
   - 配置驱动的行为控制

3. **生产级特性**
   - 服务注册与发现
   - 负载均衡
   - 容错重试
   - 心跳检测

### 3. 代码质量

- 清晰的模块划分
- 完善的异常处理
- 详细的注释文档
- 单元测试覆盖

## 使用示例

### 服务提供者

```java
// 1. 定义服务接口
public interface UserService {
    User getUser(User user);
}

// 2. 实现服务
public class UserServiceImpl implements UserService {
    @Override
    public User getUser(User user) {
        // 业务逻辑
        return new User("张三", 18);
    }
}

// 3. 注册并启动服务
public class ProviderExample {
    public static void main(String[] args) {
        // 注册服务
        LocalRegistry.register(UserService.class.getName(), UserServiceImpl.class);

        // 启动TCP服务器
        VertxTcpServer.start();
    }
}
```

### 服务消费者

```java
public class ConsumerExample {
    public static void main(String[] args) {
        // 获取服务代理
        UserService userService = ServiceProxyFactory.getProxy(UserService.class);

        // 调用远程服务
        User user = new User();
        User result = userService.getUser(user);

        System.out.println(result);
    }
}
```

## 可优化点

### 1. 性能优化
- 连接池管理（目前每次请求创建新连接）
- 批量请求支持
- 异步调用支持
- 结果缓存机制

### 2. 功能增强
- 服务熔断降级
- 分布式链路追踪
- 监控指标收集
- 配置中心集成

### 3. 架构改进
- 调用链模式重构（解耦ServiceProxy）
- 插件化架构
- 更完善的SPI机制
- 服务网格支持

## 总结

yu-rpc是一个设计良好、功能完整的RPC框架示例，虽然代码量不大，但涵盖了分布式系统的核心概念和最佳实践。通过学习这个项目，可以深入理解：

1. RPC框架的核心原理
2. 分布式系统的服务治理
3. 高性能网络编程技巧
4. 设计模式的实际应用
5. 框架设计的方法论

项目非常适合作为学习RPC原理和分布式系统设计的入门项目，也为进一步的扩展和优化留下了充足的空间。